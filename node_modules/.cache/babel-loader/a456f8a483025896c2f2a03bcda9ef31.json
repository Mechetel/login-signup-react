{"ast":null,"code":"'use strict';\n\nvar random = require('./lib/random').default;\n\nvar sets = require('./lib/character-sets');\n\nvar util = require('./lib/util');\n\nObject.keys(sets).forEach(function (k) {\n  exports[k] = sets[k];\n});\nvar defaultAmbiguousSets = ['Il1|', 'O0'];\n\nfunction randomPassword(opts) {\n  var defaults = {\n    avoidAmbiguous: true,\n    characters: [sets.lower, {\n      characters: sets.upper,\n      exactly: 1\n    }, {\n      characters: sets.symbols,\n      exactly: 1\n    }],\n    length: 12,\n    predicate: function predicate() {\n      return true;\n    },\n    random: random\n  };\n  opts = util.assign({}, defaults, opts);\n  var characterRules = translateRules(opts);\n\n  if (!util.isInteger(opts.length)) {\n    throw new Error('length must be an integer');\n  }\n\n  if (opts.length < 1) {\n    throw new Error('length must be > 0');\n  }\n\n  if (opts.length < characterRules.length) {\n    throw new Error('length must be >= # of character sets passed');\n  }\n\n  if (characterRules.some(function (rule) {\n    return !rule.characters;\n  })) {\n    throw new Error('No character set may be empty');\n  }\n\n  if (characterRules.length === 0) {\n    throw new Error('Must pass one or more character sets');\n  }\n\n  if (typeof opts.predicate !== 'function') {\n    throw new Error('predicate must be a function');\n  }\n\n  var minimumLength = characterRules.map(function (rule) {\n    return rule.exactly || 1;\n  }).reduce(function (l, r) {\n    return l + r;\n  }, 0);\n\n  if (opts.length < minimumLength) {\n    throw new Error('length is too short for character set rules');\n  }\n\n  var allExactly = characterRules.every(function (rule) {\n    return rule.exactly;\n  });\n\n  if (allExactly) {\n    var exactlyLength = characterRules.reduce(function (acc, r) {\n      return acc + r.exactly;\n    }, 0);\n\n    if (exactlyLength !== opts.length) {\n      throw new Error('Must pass a set without exactly rule to generate the specified length');\n    }\n  }\n\n  var result;\n\n  do {\n    result = generatePassword(characterRules, opts.length, opts.random);\n  } while (!opts.predicate(result));\n\n  return result;\n}\n\nexports.randomPassword = randomPassword;\n\nfunction generatePassword(characterRules, length, random) {\n  var requiredSetsWithRepeats = characterRules.map(function (rule) {\n    return rule.exactly ? util.repeat(rule.characters, rule.exactly) : [rule.characters];\n  }).reduce(function (l, r) {\n    return l.concat(r);\n  }); // flatten back to array of strings\n\n  var requiredChoices = requiredSetsWithRepeats.map(function (characters) {\n    return random.choose(characters);\n  });\n  var fillCharcters = characterRules.filter(function (rule) {\n    return !rule.exactly;\n  }).map(function (rule) {\n    return rule.characters;\n  }).join('');\n  var randomChoices = util.range(length - requiredChoices.length).map(function () {\n    return random.choose(fillCharcters);\n  });\n  var shuffled = random.shuffle(requiredChoices.concat(randomChoices));\n  return shuffled.join('');\n}\n\nfunction translateRules(opts) {\n  if (!opts.characters) {\n    return [];\n  }\n\n  var result = Array.isArray(opts.characters) ? opts.characters : [opts.characters];\n  result = result.map(function (x) {\n    return util.isString(x) ? {\n      characters: x\n    } : x;\n  });\n  var ambiguousSets = opts.avoidAmbiguous === true ? defaultAmbiguousSets : opts.avoidAmbiguous || [];\n  stripAmbiguous(result, ambiguousSets);\n  return result;\n}\n\nfunction stripAmbiguous(characterRules, ambiguousSets) {\n  var allCharacters = characterRules.map(function (rule) {\n    return rule.characters;\n  }).join('');\n  var ambiguousCharacters = ambiguousSets.filter(function (ambiguousSet) {\n    return util.intersection(ambiguousSet, allCharacters).length > 1;\n  }).join('');\n  characterRules.forEach(function (rule) {\n    rule.characters = util.toArray(rule.characters).filter(function (ch) {\n      return ambiguousCharacters.indexOf(ch) < 0;\n    }).join('');\n  });\n}\n\nfunction randomString(opts) {\n  var defaults = {\n    characters: [sets.lower, sets.upper, sets.digits, sets.symbols],\n    length: 20\n  };\n  opts = util.assign({}, defaults, opts);\n  opts.avoidAmbiguous = false; // hard override\n\n  return randomPassword(opts);\n}\n\nexports.randomString = randomString;","map":null,"metadata":{},"sourceType":"script"}