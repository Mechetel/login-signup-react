{"ast":null,"code":"import _slicedToArray from \"/Users/dmitryhoma/Projects/login-signup-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// Detect either spaces or tabs but not both to properly handle tabs for indentation and spaces for alignment\nvar INDENT_REGEX = /^(?:( )+|\\t+)/;\nvar INDENT_TYPE_SPACE = 'space';\nvar INDENT_TYPE_TAB = 'tab';\n/**\nMake a Map that counts how many indents/unindents have occurred for a given size and how many lines follow a given indentation.\n\nThe key is a concatenation of the indentation type (s = space and t = tab) and the size of the indents/unindents.\n\n```\nindents = {\n\tt3: [1, 0],\n\tt4: [1, 5],\n\ts5: [1, 0],\n\ts12: [1, 0],\n}\n```\n*/\n\nfunction makeIndentsMap(string, ignoreSingleSpaces) {\n  var indents = new Map(); // Remember the size of previous line's indentation\n\n  var previousSize = 0;\n  var previousIndentType; // Indents key (ident type + size of the indents/unindents)\n\n  var key;\n\n  var _iterator = _createForOfIteratorHelper(string.split(/\\n/g)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var line = _step.value;\n\n      if (!line) {\n        // Ignore empty lines\n        continue;\n      }\n\n      var indent = void 0;\n      var indentType = void 0;\n      var weight = void 0;\n      var entry = void 0;\n      var matches = line.match(INDENT_REGEX);\n\n      if (matches === null) {\n        previousSize = 0;\n        previousIndentType = '';\n      } else {\n        indent = matches[0].length;\n        indentType = matches[1] ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB; // Ignore single space unless it's the only indent detected to prevent common false positives\n\n        if (ignoreSingleSpaces && indentType === INDENT_TYPE_SPACE && indent === 1) {\n          continue;\n        }\n\n        if (indentType !== previousIndentType) {\n          previousSize = 0;\n        }\n\n        previousIndentType = indentType;\n        weight = 0;\n        var indentDifference = indent - previousSize;\n        previousSize = indent; // Previous line have same indent?\n\n        if (indentDifference === 0) {\n          weight++; // We use the key from previous loop\n        } else {\n          var absoluteIndentDifference = indentDifference > 0 ? indentDifference : -indentDifference;\n          key = encodeIndentsKey(indentType, absoluteIndentDifference);\n        } // Update the stats\n\n\n        entry = indents.get(key);\n        entry = entry === undefined ? [1, 0] : [++entry[0], entry[1] + weight];\n        indents.set(key, entry);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return indents;\n} // Encode the indent type and amount as a string (e.g. 's4') for use as a compound key in the indents Map.\n\n\nfunction encodeIndentsKey(indentType, indentAmount) {\n  var typeCharacter = indentType === INDENT_TYPE_SPACE ? 's' : 't';\n  return typeCharacter + String(indentAmount);\n} // Extract the indent type and amount from a key of the indents Map.\n\n\nfunction decodeIndentsKey(indentsKey) {\n  var keyHasTypeSpace = indentsKey[0] === 's';\n  var type = keyHasTypeSpace ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n  var amount = Number(indentsKey.slice(1));\n  return {\n    type: type,\n    amount: amount\n  };\n} // Return the key (e.g. 's4') from the indents Map that represents the most common indent,\n// or return undefined if there are no indents.\n\n\nfunction getMostUsedKey(indents) {\n  var result;\n  var maxUsed = 0;\n  var maxWeight = 0;\n\n  var _iterator2 = _createForOfIteratorHelper(indents),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          key = _step2$value[0],\n          _step2$value$ = _slicedToArray(_step2$value[1], 2),\n          usedCount = _step2$value$[0],\n          weight = _step2$value$[1];\n\n      if (usedCount > maxUsed || usedCount === maxUsed && weight > maxWeight) {\n        maxUsed = usedCount;\n        maxWeight = weight;\n        result = key;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return result;\n}\n\nfunction makeIndentString(type, amount) {\n  var indentCharacter = type === INDENT_TYPE_SPACE ? ' ' : '\\t';\n  return indentCharacter.repeat(amount);\n}\n\nexport default function detectIndent(string) {\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a string');\n  } // Identify indents while skipping single space indents to avoid common edge cases (e.g. code comments)\n  // If no indents are identified, run again and include all indents for comprehensive detection\n\n\n  var indents = makeIndentsMap(string, true);\n\n  if (indents.size === 0) {\n    indents = makeIndentsMap(string, false);\n  }\n\n  var keyOfMostUsedIndent = getMostUsedKey(indents);\n  var type;\n  var amount = 0;\n  var indent = '';\n\n  if (keyOfMostUsedIndent !== undefined) {\n    var _decodeIndentsKey = decodeIndentsKey(keyOfMostUsedIndent);\n\n    type = _decodeIndentsKey.type;\n    amount = _decodeIndentsKey.amount;\n    indent = makeIndentString(type, amount);\n  }\n\n  return {\n    amount: amount,\n    type: type,\n    indent: indent\n  };\n}","map":null,"metadata":{},"sourceType":"module"}